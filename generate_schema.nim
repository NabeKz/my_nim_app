## スキーマファイル生成ツール
## データベースに接続してスキーマを取得し、Nimファイルを生成

import std/os
import std/strformat
import std/strutils
import std/sequtils
import std/tables
import db_connector/db_sqlite
import src/shared/schema_parser

# SQLクエリ定数
const USER_TABLES_QUERY = sql"""
  SELECT sql FROM sqlite_master 
  WHERE type='table' 
    AND sql IS NOT NULL 
    AND name NOT LIKE 'sqlite_%'
"""

# データベースからCREATE文を取得
proc extractCreateStatements*(dbPath: string): seq[string] =
  echo &"Extracting CREATE statements from database: {dbPath}"
  
  let conn = open(dbPath, "", "", "")
  defer: conn.close()
  
  # スキーマ情報を取得（システムテーブルを除外）
  let rows = conn.getAllRows(USER_TABLES_QUERY)
  rows.mapIt(it[0])

# CREATE文からスキーマを解析
proc parseSchema*(createStatements: seq[string]): DatabaseSchema =
  echo "Parsing database schema..."
  parseSchemaFromCreateStatements(createStatements)

# ヘルパー関数: 制約セットを文字列に変換
func constraintsToString(constraints: set[ColumnConstraint]): string =
  if constraints.card == 0:
    "{}"
  else:
    let parts = block:
      var constraintParts: seq[string] = @[]
      if ccPrimaryKey in constraints: constraintParts.add("ccPrimaryKey")
      if ccNotNull in constraints: constraintParts.add("ccNotNull") 
      if ccUnique in constraints: constraintParts.add("ccUnique")
      if ccAutoIncrement in constraints: constraintParts.add("ccAutoIncrement")
      constraintParts
    "{" & parts.join(", ") & "}"

# ヘルパー関数: カラム情報をNimコードに変換
func columnToNimCode(col: ColumnInfo): string =
  let constraintsStr = constraintsToString(col.constraints)
  &"      ColumnInfo(name: \"{col.name}\", sqliteType: {col.sqliteType}, constraints: {constraintsStr}),"

# ヘルパー関数: テーブルスキーマをNimコードに変換
func tableSchemaToNimCode(tableName: string, tableSchema: TableSchema): string =
  let columnsCode = tableSchema.columns
    .mapIt(columnToNimCode(it))
    .join("\n")
  
  &"""  schema.tables["{tableName}"] = TableSchema(
    name: "{tableName}",
    columns: @[
{columnsCode}
    ]
  )"""

# ヘルパー関数: 全スキーマをNimコードに変換
func generateSchemaCode(dbSchema: DatabaseSchema): string =
  let tablesCode = block:
    var tableCodes: seq[string] = @[]
    for tableName, tableSchema in dbSchema.tables:
      tableCodes.add(tableSchemaToNimCode(tableName, tableSchema))
    tableCodes.join("\n\n")
  
  &"""# Auto-generated database schema
# Generated by generate_schema.nim

import std/tables
import std/options
import src/shared/schema_parser

const GENERATED_SCHEMA* = block:
  var schema = DatabaseSchema(tables: initTable[string, TableSchema]())
  
{tablesCode}

  schema
"""

proc generateSchemaFile*(dbSchema: DatabaseSchema, outputPath: string) =
  echo &"Generating schema file: {outputPath}"
  
  # 関数型的にNimコードを生成
  let nimCode = generateSchemaCode(dbSchema)
  
  # ファイルに書き出し
  writeFile(outputPath, nimCode)
  echo &"Schema file generated: {outputPath}"

# 型定義も生成
proc generateTypeDefinitions*(dbSchema: DatabaseSchema, outputPath: string) =
  let typeCode = generateAllNimTypes(dbSchema)
  writeFile(outputPath, typeCode)
  echo &"Type definitions generated: {outputPath}"

when isMainModule:
  if paramCount() < 1:
    echo "Usage: nim r generate_schema.nim <database_path>"
    echo "       For testing: nim r tests/test_schema_generation.nim"
    quit(1)
  
  let dbPath = paramStr(1)
  if not fileExists(dbPath):
    echo &"Error: Database file '{dbPath}' not found"
    quit(1)
  
  echo &"Processing database: {dbPath}"
  
  # データベースからCREATE文を取得
  let createStatements = extractCreateStatements(dbPath)
  
  # スキーマを解析
  let dbSchema = parseSchema(createStatements)
  
  # 両方のファイルを生成
  generateSchemaFile(dbSchema, "db_schema.nim")
  generateTypeDefinitions(dbSchema, "generated_types.nim")
  
  echo "✅ Schema generation completed!"